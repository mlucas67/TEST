SUBROUTINE LCS( DATAA, LOWERA, UPPERA, DATAB, LOWERB, UPPERB, DOWNVECTOR, UPVECTOR )
    EQU TRUE TO 1
    EQU FALSE TO 0
    
    DATAA.LENGTH = DATAA<1>
    DATAA.MODIFIED = RAISE( DATAA<2> )
    DATAA.DATA = RAISE( DATAA<3> )
    DATAB.LENGTH = DATAB<1>
    DATAB.MODIFIED = RAISE( DATAB<2> )
    DATAB.DATA = RAISE( DATAB<3> )
    LOOP
    WHILE ((LOWERA < UPPERA) & (LOWERB < UPPERB) & (DATAA.DATA<LOWERA> = DATAB.DATA<LOWERB>))
        LOWERA += 1
        LOWERB += 1
    REPEAT
    LOOP
    WHILE ((LOWERA < UPPERA) & (LOWERB < UPPERB) & (DATAA.DATA<UPPERA - 1> = DATAB.DATA<UPPERB - 1>))
        UPPERA = UPPERA - 1
        UPPERB = UPPERB - 1
    REPEAT
    IF (LOWERA = UPPERA) THEN
        LOOP
        WHILE (LOWERB < UPPERB)
            DATAB.MODIFIED<LOWERB> = TRUE
            DATAB<2> = LOWER( DATAB.MODIFIED )
            LOWERB += 1
        REPEAT
    END ELSE
        IF (LOWERB = UPPERB) THEN
            LOOP
            WHILE (LOWERA < UPPERA)
                DATAA.MODIFIED<LOWERA> = TRUE
                DATAA<2> = LOWER( DATAA.MODIFIED )
                LOWERA += 1
            REPEAT
        END ELSE
            CALL SMS( SMSRD, DATAA, LOWERA, UPPERA, DATAB, LOWERB, UPPERB, DOWNVECTOR, UPVECTOR )
            ***
            *** SMSRD = SHORTEST MIDDLE SNAKE RETURN DATA
            ***   <1> = X
            ***   <2> = Y
            ***
            SMSRD.X = SMSRD<1>
            SMSRD.Y = SMSRD<2>
            CALL LCS( DATAA, LOWERA, SMSRD.X, DATAB, LOWERB, SMSRD.Y, DOWNVECTOR, UPVECTOR )
            CALL LCS( DATAA, SMSRD.X, UPPERA, DATAB, SMSRD.Y, UPPERB, DOWNVECTOR, UPVECTOR )
        END
    END
    
    RETURN

END ;* LCS
