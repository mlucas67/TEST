$catalog Toy local
class Toy
    private pc, R, mem, opcodes
    
    public sub create.object( filename, itemname )
        mem = str( '0':@fm, 255 ) : '0'
        R = str( '0':@fm, 15 ) : '0'
        pc = 0x10
        
        me->load_opcodes()
        
        me->load( filename, itemname )
        
        display @(-1):
        me->dump( pc, R, mem )
        
        me->execute()
    end
    
    public sub execute()
        loop
        while (@true)
            !! fetch and parse
            inst = mem<pc+1>
            pc += 1
            op = bitand( shift( inst, 12 ), 15 )
            d = bitand( shift( inst, 8 ), 15 )+1
            s = bitand( shift( inst, 4 ), 15 )+1
            t = bitand( inst, 15 )+1
            addr = bitand( inst, 255 )
            
            me->show_inst(op,d-1,s-1,t-1,addr)
            
            !! halt
            if (op = 0) then exit
            
            !! stdin
            if (((addr = 255) & (op = 8)) ! ((R<t> = 255) & (op = 10))) then
                input stdin
                mem<256> = me->fromHex( stdin )
            end
            
            !! execute
            begin case
                case (op = 1)
                    !! add
                    R<d> = R<s> + R<t>
                case (op = 2)
                    !! subtract
                    R<d> = R<s> - R<t>
                case (op = 3)
                    !! bitwise and
                    R<d> = bitand( R<s>, R<t> )
                case (op = 4)
                    !! bitwise xor
                    R<d> = bitxor( R<s>, R<t> )
                case (op = 5)
                    !! shift left
                    R<d> = shift( R<s>, -1 * R<t> )
                case (op = 6)
                    !! shift right
                    R<d> = shift( R<s>, R<t> )
                case (op = 7)
                    !! load address
                    R<d> = addr
                case (op = 8)
                    !! load
                    R<d> = mem<addr+1>
                case (op = 9)
                    !! store
                    mem<addr+1> = R<d>
                case (op = 10)
                    !! load indirect
                    R<d> = mem<bitand( R<t>, 255 )+1>
                case (op = 11)
                    !! store indirect
                    mem<bitand( R<t>, 255 )+1> = R<d>
                case (op = 12)
                    !! branch if zero
                    if (R<d> = 0) then pc = addr
                case (op = 13)
                    !! branch if positive
                    if (R<d> > 0) then pc = addr
                case (op = 14)
                    !! jump indirect
                    pc = R<d>
                case (op = 15)
                    !! jump and link
                    R<d> = pc
                    pc = addr 
            end case
            
            !! stdout
            if (((addr = 255) & (op = 9)) ! ((R<t> = 255) & (op = 11))) then
                display me->toHex( mem<256> )
            end
            
            R<1> = 0
            R<d> = bitand( R<d>, 0xFFFF )
            pc = bitand( pc, 0xFF )
            me->dump( pc, R, mem )
            dummy = keyin()
        repeat
    end

    public sub load_opcodes()
        opcodes = ''
        opcodes<1> =  "addýR[%d] <- R[%s] + R[%t]"
        opcodes<2> =  "subtractýR[%d] <- R[%s] - R[%t]"
        opcodes<3> =  "andýR[%d] <- R[%s] & R[%t]"
        opcodes<4> =  "xorýR[%d] <- R[%s] ^ R[%t]"
        opcodes<5> =  "left shiftýR[%d] <- R[%s] << R[%t]"
        opcodes<6> =  "right shiftýR[%d] <- R[%s] >> R[%t]"
        opcodes<7> =  "load addressýR[%d] <- %addr"
        opcodes<8> =  "loadýR[%d] <- mem[%addr]"
        opcodes<9> =  "storeýmem[%addr] <- R[%d]"
        opcodes<10> = "load indirectýR[%d] <- mem[R[%t]]"
        opcodes<11> = "store indirectýmem[R[%t]] <- R[%d]"
        opcodes<12> = "branch zeroýif (R[%d] == 0) pc <- %addr"
        opcodes<13> = "branch positiveýif (R[%d] > 0) pc <- %addr"
        opcodes<14> = "jump registerýpc <- R[%d]"
        opcodes<15> = "jump and linkýR[%d] <- pc; pc <- %addr"
    end

    public sub show_inst(op,d,s,t,addr)
        if (op = 0) then 
            output = "halt"
        end else
            template = opcodes<op,2>
            begin case
                case (template matches "0X'%d'0X'%s'0X'%t'0X")
                    output = parse( template, "0X'%d'0X'%s'0X'%t'0X", @fm )
                    output<2> = me->toHex( d )'r%1'
                    output<4> = me->toHex( s )'r%1'
                    output<6> = me->toHex( t )'r%1'
                case (template matches "0X'%d'0X'%t'0X")
                    output = parse( template, "0X'%d'0X'%t'0X", @fm )
                    output<2> = me->toHex( d )'r%1'
                    output<4> = me->toHex( t )
                case (template matches "0X'%t'0X'%d'0X")
                    output = parse( template, "0X'%t'0X'%d'0X", @fm )
                    output<2> = me->toHex( t )'r%1'
                    output<4> = me->toHex( d )'r%1'
                case (template matches "0X'%d'0X'%addr'0X")
                    output = parse( template, "0X'%d'0X'%addr'0X", @fm )
                    output<2> = me->toHex( d )'r%1'
                    output<4> = me->toHex( addr )'r%2'
                case (template matches "0X'%addr'0X'%d'0X")
                    output = parse( template, "0X'%addr'0X'%d'0X", @fm )
                    output<2> = me->toHex( addr )'r%2'
                    output<4> = me->toHex( d )'r%1'
                case (template matches "0X'%d'0X")
                    output = parse( template, "0X'%d'0X", @fm )
                    output<2> = me->toHex( d )'r%1'
            end case
            output = convert( @fm, '', output )
        end
        crt output : @(-4) :
    end

    public sub load( filename, itemname )
        open filename to f.file else stop 201, filename
        read source from f.file, itemname else stop 202, itemname
        source.length = dcount( source, @fm )
        
        for i = 1 to source.length
            line = trim( source<i> )
            if (line matches "2X':' ''4X' '0X") then
                addr = me->fromHex( matchfield( line, "2X':'' '4X' '0X", 1 ) )
                inst = me->fromHex( trim( matchfield( line, "2X':'' '4X' '0X", 4 ) ) )
                mem<addr+1> = inst
            end
        next i
    end

    public function toHex( n )
        return oconv( n, "MCDX" )'r%4'
    end
    
    public function fromHex( s )
        return oconv( s, "MCXD" )
    end
    
    public sub show( a )
        a.length = dcount( a, @fm )
        display me->toHex( a<1> )
        for i = 2 to a.length
            display me->toHex( a<i> ) : " " :
            if (mod( (i-1), 15 ) = 0) then display
        next i
        if (mod( (i-1), 15 ) # 0) then display
    end
    
    public sub dump( pc, R, mem )
        display @(0,0):
        display "PC: " : me->toHex( pc )'r%2'
        display "Registers:" :
        me->show( R )
        display "Main memory:" :
        me->show( mem )
    end
    
end
